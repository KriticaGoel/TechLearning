
AGENDA
[Authentication Flow and Challenges](#authentication-flow-and-challenges)


#### Authentication Flow and Challenges
1. Basic Authentication (Username & Password in Every Request)
   
    **Process:**
   The client sends the username and password with every API request.

    **Problems:**

    1. The client has to send credentials repeatedly, which is inconvenient and insecure.
    2. The server has to validate credentials from the database on every request, which adds performance overhead.

2. Token-Based Authentication (Session Token Stored in DB)


   **Solution:**
   After validating the user's credentials once, the server generates a token and stores it in the database.
   The client stores this token in memory or cache and sends it with each subsequent request.
   

 **Pros:**

✅ Solves Problem 1.1 (no need to send credentials repeatedly).

**Remaining Issue:**

❌ Problem 1.2 still exists — the server must look up the token in the database for every request to validate it

3. JWT (JSON Web Token) Authentication

   **Solution:**


   Use JWT, a stateless token signed using a secret or public/private key.
   

The token contains user claims and can be verified without querying the database.

How it solves Problem 1.2:


✅ The server validates the token locally (using the signature), eliminating the need for a DB lookup on each request.


### Password
1. Plaintext Password (Not Recommended)

   Password is stored as-is (e.g., "abc").

    ❌ Highly insecure — if the database is compromised, all passwords are exposed
2. Hashing (e.g., SHA-256)

   Passwords are stored as a hashed value (e.g., SHA-256("abc")).

    ✅ More secure than plaintext.

    Problem:

    a. Same input always results in the same output.

    b. If multiple users have the same password, they will have the same hashed value.

    c. Vulnerable to rainbow table attacks.
3. Hashing + Salting
   
    Add a random salt to each password before hashing:
    
    SHA-256("abc" + random_salt)

    ✅ Produces different hashes even for the same password.

    ✅ Makes rainbow table attacks ineffective.

    ❌ Still needs secure management of salts and is more complex to implement correctly.

4. Bcrypt Password Encoder
   
    Bcrypt is a modern password hashing function designed for security:

    Automatically generates a unique salt.

    Rehashes multiple times (configurable work factor).

    Output is always different even for the same input.

    ✅ More secure than plain hashing + salting.

    ❌ Problem: Since output is different each time, you cannot directly compare stored and input hashes.

5. matches() Method in Bcrypt
   
    Bcrypt provides a built-in matches(rawPassword, hashedPassword) method.

    ✅ It handles salt and internal hashing logic.

    ✅ Allows safe comparison of raw password with a hashed one.


### How Authorization works:

1. Client send username and password to server
2. Server will do following steps:   
   1. Verify the credentials 
   2. Generate JSON having parameters like
      {
        "user_id" : "  ";
        "expiry_at" : "  ";
         "value" : "  ";
         "role" : " ";
      }
   3. Generate Token form JSON
   4. Encode token using base64encoder. This is not secure since anyone can decode it using base64.
   5. Encrypt using token and secret key
   6. Return encrypt token


















