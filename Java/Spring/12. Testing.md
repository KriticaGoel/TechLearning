1. Functional Testing
2. [Unit Testing](#unit-test-case)
   1. [Create Test File in STS](#create-a-test-file-in-sts)
   2. [Basic Annotation](#basic-annotation)
      1. ExtendWith
      2. DisplayName
      3. Test
      4. Disable
      5. BeforeEach and AfterEach
      6. BeforeAll and AfterAll
      7. Condition Annotations
         1. Operating system based annotation
            1. EnableOnOs or DisableOnOs
         2. JRE version based annotation
            1. EnableOnJre or DisableOnJre
            2. EnableOnJreRange or DisableOnJreRange
         3. System Property Conditions
            1. EnabledIfSystemProperty or DisabledIfSystemProperty
         4. Environment variable condition
            1. EnabledIfEnvironmentVariable or DisabledIfEnvironmentVariable
         5. Custom condition
            1. EnabledIf or DisabledIf
      8. Controlling the execution order of test
      9. Repeated Test
      10. Nested Test
   3. [Assertions](#assertions)
      1. Assertion and why needed
      2. AssertEquals
      3. AssertNotEquals
      4. WorkingWithArray
      5. AssertTrue
      6. AssertFalse
3. Integration Testing


#### Unit test case

##### Create a test file in STS

1. Open STS and the Package Explorer (or Project Explorer).
2. Locate the Java class you want to test (e.g., src/main/java/com/example/demo/Calculator.java).
3. Right‑click the class file → New → JUnit Test Case.
4. If you don’t see “JUnit Test Case”: choose New → Other… → type “JUnit” → JUnit → JUnit Test Case.

##### Basic Annotation
1. **@ExtendWith**
2. **@DisplayName**
3. **@Test** - method is always public and void and no parameter
4. **@Disabled**

```java
@ExtendWith(MockitoExtension.class)
@DisplayName("Payment Controller Unit Test")
class PaymentControllerTest {
	
	
	@Test
	@DisplayName("Positive test case")
	void successes() {
		
	}
	
	@Test
	@DisplayName("Negative Test Case")
	void failed() {
		fail();
	}
	
	@Test
	@Disabled
	@DisplayName("Ignore Test Case")
	void ignored() {
		
	}

}
```

5. **@BeforeEach** - Execute before every test to be executed.
6. **@AfterEach** - Execute after every test to be executed.
```java
class CalculatorTest {

    @BeforeEach
    void setUp()  {
        System.out.println("Initialization done");
    }

    @Test
    @DisplayName("Addition Test")
    void testAdd() {
        System.out.println("Addition Test executed");

    }

    @Test
    @DisplayName("Subtraction Test")
    void testSubtract() {
        System.out.println("Subtraction Test executed");

    }

    @AfterEach
    void cleanUp()  {
        System.out.println("Clear the resources");
    }
}
```

```terminaloutput
Initialization done
Addition Test executed
Clear the resources
Initialization done
Subtraction Test executed
Clear the resources
```

7. **BeforeAll**  - Execute as a first method and only once and always be static

8. **After All** -  Execute as a last method and only once and always be static
```java
class CalculatorTest {
	
	@BeforeAll
	public static void openDatabase() {
		System.out.println("Database connection opened");
	}
	
	@BeforeEach
	void setUp() {
		System.out.println("Initialization done");
	}
	
	@Test
	@DisplayName("Addition Test")
	void testAdd() {
		System.out.println("Addition Test executed");
		
	}
	
	@Test
	@DisplayName("Subtraction Test")
	void testSubtract() {
		System.out.println("Subtraction Test executed");
		
	}
	
	@AfterEach
	void cleanUp() {
		System.out.println("Clear the resources");
	}
	
	@AfterAll
	public static void closeDatabase() {
		System.out.println("Database connection closed");
	}   
}
```

```terminaloutput
Database connection opened
Initialization done
Addition Test executed
Clear the resources
Initialization done
Subtraction Test executed
Clear the resources
Database connection closed
```

Question: why BeforeALl usually need static while others not?

Explanation :
* Default test lifecycle in JUnit Jupiter is PER_METHOD (a new test class instance is created for each test method). Because of that:
* There is no single shared test-instance available before any test methods run (JUnit creates instances per test). The test engine cannot reliably call an instance method "once for the whole class" if instances are created per test.
* Marking the method static gives JUnit a single, class-level method to call once before all tests run (and once after all tests).
* In short: static = no instance required, so it works with the default PER_METHOD lifecycle.

When you can make them non-static

* If you annotate the class with @TestInstance(Lifecycle.PER_CLASS), JUnit creates a single instance of the test class and re-uses it for all test methods. Because one instance exists for the whole class, @BeforeAll and @AfterAll may be instance methods (non-static).
* @TestInstance(Lifecycle.PER_CLASS) at the class level and then non-static @BeforeAll / @AfterAll.

**Best practices and cautions** - Prefer PER_METHOD (the default) when you want strong test isolation: each test gets its own instance and cannot accidentally share mutable state with others.

9. Condition Annotations:
   1. Operating system based annotation
      1.  **EnableOnOs(OS.WINDOWS)**
      2.  **DisableOnOs(OS.WINDOWS)**
   2. JRE version based annotation
      1.  **EnableOnJre(JRE.JAVA_14)**
      2.  **EnableOnJre({JRE.JAVA_10,JRE.JAVA_21})**  - Enable on multiple version specific in {}
      3.  **DisableOnJre(JRE.JAVA_14)** - Disable on jre 14
      4.  **DisableOnJre({JRE.JAVA_10,JRE.JAVA_21})** - Disable on multiple version specific in {}
      5.  **EnableOnJreRange(min = JRE.JAVA_10, max = JRE.JAVA-21)** - Enable between mentioned range. Only one parameter is also valid like min = JRE.JAVA-21 that means all JAVA version starting from 21 is valid.
      6.  **DisableOnJreRange**
   3. System Property Conditions  - System.getProperties gives all system properties of JVM. the we can enable the test case based on thosed proeprties
      1.  **EnabledIfSystemProperty(named="USER" , matches ="Kritica")**  - test case run of parameter and value matches with system properites.
      2.  **DisableIfSystemProperty**
   
```java
public class SystemPropertyConditions {

    @Test
    public void getSystemProperties() {
        System.out.println("System Properties: " + System.getProperties());
        System.out.println("Java Version: " + System.getProperty("java.version"));
    }

    @Test
    @EnabledIfSystemProperty(named = "os.name", matches = ".*Windows.*")
    public void runOnlyOnWindows() {
        System.out.println("This test runs only on Windows OS");
    }

}

```
```terminaloutput
This test runs only on Windows OS
```
      
   4. Environment variable condition
     1.  **EnabledIfEnvironmentVariable(named="USER" , matches ="Kritica")** - EnabledIfEnvironmentVariable named contain environment variable key and matches contains its value. If name and key matches then only test cases execute otherwise not. 
   5. Custom condition - Used to enable or disable the test method based on the boolean value that custom method returns (based on some calculations).
      1. EnabledIf 
      2. DisabledIf

```Java
public class CustomCondition {
	
	@Test
	@EnabledIf("isConditionMet")
	public void customCondition() {
		System.out.println("This is a custom condition example");
	}

	public boolean isConditionMet() {
		// Custom logic to determine if the condition is met
		int a = 10;
		int b = 20;
		if (a + b > b) {
			return true;
		} else {
			return true;
		}
	}

}

```
```terminaloutput
This is a custom condition example
```
10. Controlling the execution order of test - Helps in defining order in which test method executes

```java
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class ControlOrderExecution {

	@Test
	@Order(1)
	public void test1() {
		System.out.println("Test 1 executed");
	} 
	
	@Test
	@Order(2)
	public void test2() {
		System.out.println("Test 2 executed");
	}
	@Test
	@Order(3)
	public void test3() {
		System.out.println("Test 3 executed");
	}
	@Test
	@Order(4)
	public void test4() {
		System.out.println("Test 4 executed");
	}
}
```

```terminaloutput
Test 1 executed
Test 2 executed
Test 3 executed
Test 4 executed
```
11. Repeated Test - Its helps in execute any test multiple times. Number of times we need to give as a argument.

```java
@RepeatedTest(5)
	public void repeatTest() {
		System.out.println("This test is repeated 5 times");
	}
```
```terminaloutput
This test is repeated 5 times
This test is repeated 5 times
This test is repeated 5 times
This test is repeated 5 times
This test is repeated 5 times
```

12.  Nested Test-


##### Assertions
