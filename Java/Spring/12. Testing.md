1. Functional Testing
2. Unit Testing
3. Integration Testing

#### Unit test case

##### Create a test file in STS

1. Open STS and the Package Explorer (or Project Explorer).
2. Locate the Java class you want to test (e.g., src/main/java/com/example/demo/Calculator.java).
3. Right‑click the class file → New → JUnit Test Case.
4. If you don’t see “JUnit Test Case”: choose New → Other… → type “JUnit” → JUnit → JUnit Test Case.

##### Basic Annotation
1. @ExtendWith
2. @DisplayName
3. @Test - method is always public and void and no parameter
4. @Disabled

```java
@ExtendWith(MockitoExtension.class)
@DisplayName("Payment Controller Unit Test")
class PaymentControllerTest {
	
	
	@Test
	@DisplayName("Positive test case")
	void successes() {
		
	}
	
	@Test
	@DisplayName("Negative Test Case")
	void failed() {
		fail();
	}
	
	@Test
	@Disabled
	@DisplayName("Ignore Test Case")
	void ignored() {
		
	}

}
```

5. @BeforeEach - Execute before every test to be executed.
6. @AfterEach - Execute after every test to be executed.
```java
class CalculatorTest {

    @BeforeEach
    void setUp()  {
        System.out.println("Initialization done");
    }

    @Test
    @DisplayName("Addition Test")
    void testAdd() {
        System.out.println("Addition Test executed");

    }

    @Test
    @DisplayName("Subtraction Test")
    void testSubtract() {
        System.out.println("Subtraction Test executed");

    }

    @AfterEach
    void cleanUp()  {
        System.out.println("Clear the resources");
    }
}
```
```terminaloutput
Initialization done
Addition Test executed
Clear the resources
Initialization done
Subtraction Test executed
Clear the resources
```

7. BeforeAll  - Execute as a first method and only once and always be static
8. After All -  Execute as a last method and only once and always be static
```java
class CalculatorTest {
	
	@BeforeAll
	public static void openDatabase() {
		System.out.println("Database connection opened");
	}
	
	@BeforeEach
	void setUp() throws Exception {
		System.out.println("Initialization done");
	}
	
	@Test
	@DisplayName("Addition Test")
	void testAdd() {
		System.out.println("Addition Test executed");
		
	}
	
	@Test
	@DisplayName("Subtraction Test")
	void testSubtract() {
		System.out.println("Subtraction Test executed");
		
	}
	
	@AfterEach
	void cleanUp() throws Exception {
		System.out.println("Clear the resources");
	}
	
	@AfterAll
	public static void closeDatabase() {
		System.out.println("Database connection closed");
	}   
}
```

```terminaloutput
Database connection opened
Initialization done
Addition Test executed
Clear the resources
Initialization done
Subtraction Test executed
Clear the resources
Database connection closed
```

Question: why BeforeALl usually need static while others not?

Explanation :
* Default test lifecycle in JUnit Jupiter is PER_METHOD (a new test class instance is created for each test method). Because of that:
* There is no single shared test-instance available before any test methods run (JUnit creates instances per test). The test engine cannot reliably call an instance method "once for the whole class" if instances are created per test.
* Marking the method static gives JUnit a single, class-level method to call once before all tests run (and once after all tests).
* In short: static = no instance required, so it works with the default PER_METHOD lifecycle.

When you can make them non-static

* If you annotate the class with @TestInstance(Lifecycle.PER_CLASS), JUnit creates a single instance of the test class and re-uses it for all test methods. Because one instance exists for the whole class, @BeforeAll and @AfterAll may be instance methods (non-static).
* @TestInstance(Lifecycle.PER_CLASS) at the class level and then non-static @BeforeAll / @AfterAll.

**Best practices and cautions** - Prefer PER_METHOD (the default) when you want strong test isolation: each test gets its own instance and cannot accidentally share mutable state with others.

9. Condition Annotations:
   1.     Operating system based annotation
      1.    **EnableOnOs(OS.WINDOWS)**
      2.    **DisableOnOs(OS.WINDOWS)**
   2.     JRE version based annotation
      1.  **EnableOnJre(JRE.JAVA_14)**
      2.  **EnableOnJre({JRE.JAVA_10,JRE.JAVA_21})**  - Enable on multiple version specific in {}
      3.  **DisableOnJre(JRE.JAVA_14)** - Disable on jre 14
      4.  **DisableOnJre({JRE.JAVA_10,JRE.JAVA_21})** - Disable on multiple version specific in {}
      5.  **EnableOnJreRange(min = JRE.JAVA_10, max = JRE.JAVA-21)** - Enable between mentioned range. Only one parameter is also valid like min = JRE.JAVA-21 that means all JAVA version starting from 21 is valid.
      6.  **DisableOnJreRange**
   3.     System Property Conditions
      1. Enable
   4.     Environment variable condition
      1.    **EnabledIfEnvironmentVariable(named="USER" , matches ="Kritica")** - EnabledIfEnvironmentVariable named contain environment variable key and matches contains its value. If name and key matches then only test cases execute otherwise not. 
   5.     Custom condition


