Agenda

* [Exceptions](#exceptions)
* [Errors](#errors)
* [Exception Handling](#exception-handling)
    * [throw Keyword](#throw-keyword)
    * [throws Keyword](#throws-keyword)
    * [try and catch keyword](#try-and-catch-keyword)
    * [finally keyword](#finally-keyword)
      [Comparison of Final, Finally, Finalize](#comparison-of-final-finally-finalize)
      [The golden Rules of Exception Handling](#the-golden-rules-of-exception-handling)
      [Custom Exception](#custom-exception)

![Exception.png](..%2F..%2F..%2Fresources%2FException.png)

### Exceptions

1. **Checked Exception** - compile time exceptions. checked at compile time — Example: IOException, SQLException
2. **Unchecked Exception** - runtime exceptions—not checked at compiled time. Example: ArithmeticException,
   NullPointerException, ArrayIndexOutOfBoundsException, etc.

### Errors

Error is not normally trapped by the Java programs. These conditions normally happen in case of severe failures, which
are not handled by the Java programs. Errors are generated to indicate errors generated by the runtime environment.

**Example**: JVM is out of memory - Virtual Mahine Error.

Assertive Error—occur at assertive type(test case)

Normally, programs cannot recover from errors.

### Exception Handling

#### throw Keyword

* throw keyword is used to explicitly throw an exception.
* We can throw either checked or unchecked exception
* The throw keyword is mainly used to throw custom exception.

```java
public static void getPlayerScore(String playerFile) {
    if (playerFile == null || playerFile.isEmpty()) {
        //throwing custom exception
        throw new IllegalArgumentException("Player file cannot be null");
    }
    System.out.println(playerFile);
}
```

#### throws keyword

* The simplest way to “handle” an exception is to rethrow it.
* the caller must either catch the exception or rethrow it

```java
public int getPlayerScore(String playerFile) throws FileNotFoundException {

    Scanner contents = new Scanner(new File(playerFile));
    return Integer.parseInt(contents.nextLine());
}
```

![throws.png](..%2F..%2F..%2Fresources%2Fthrows.png)

#### try and catch keyword

```java
public int getPlayerScore(String playerFile) {
    try {
        Scanner contents = new Scanner(new File(playerFile));
        return Integer.parseInt(contents.nextLine());
    } catch (FileNotFoundException noFile) {
        logger.warn("File not found, resetting score.");
        return 0;
    }
}
```

#### finally keyword

It always runs whether an exception has occurred

```java
public int getPlayerScore(String playerFile)
        throws FileNotFoundException {
    Scanner contents = null;
    try {
        contents = new Scanner(new File(playerFile));
        return Integer.parseInt(contents.nextLine());
    } finally {
        if (contents != null) {
            contents.close();
        }
    }
}
```

### Comparison of Final, Finally, Finalize

| Final                                                                                           | Finally                                                                                                             | Finalize                                                                                                                                      |
|-------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| final is a keyword and access modifier                                                          | finally block is used in Java Exception Handling to execute the mandatory piece of code after try-catch blocks.     | finalize() is the method in Java.                                                                                                             |
| final non-access modifier is used to apply restrictions on the variables, methods, and classes. | finally block executes whether an exception occurs or not.                                                          | It is primarily used to close resources. finalize() method is used to perform clean-up processing just before an object is garbage collected. |
| It is used with variables, methods, and classes.                                                | It is with the try-catch block in exception handling.                                                               | It is used with objects.                                                                                                                      |
| Once declared, the final variable becomes constant and can't be modified.                       | finally block cleans up all the resources used in the try block.                                                    | finalize method performs the cleaning with respect to the object before its destruction.                                                      |
| final is executed only when we call it.                                                         | finally block executes as soon as the execution of try-catch block is completed without depending on the exception. | finalize method is executed just before the object is destroyed.                                                                              |

### The golden Rules of Exception Handling

1. **Never swallow an exception**—Swallowing an exception means that you catch it and do nothing with it. This is a bad
   practice because it means that you are ignoring the fact that an error occurred, which could cause your program to
   behave in unexpected ways and hide bugs.

```java
try{
        // do something
        }catch(Exception e){
        System.out.

println("Error: "+e.getMessage());
        }
```

2. **Never catch a generic exception** - Catching a generic exception means that you are catching all exceptions,
   including runtime exceptions. This is a bad practice because it means that you are not handling exceptions in a
   meaningful way. You should always catch specific exceptions and handle them appropriately.

```java
try{
        // do something
        }catch(Exception e){
        System.out.

println("Error: "+e.getMessage());
        }   
```

3. **Never throw a generic exception** - Throwing a generic exception means that you are throwing all exceptions,
   including runtime exceptions. This is a bad practice because it means that you are not handling exceptions in a
   meaningful way. You should always throw specific exceptions and handle them appropriately.

```java

public void doSomething() throws Exception {
    // do something
}
```

### Custom Exception

```java
public class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}


public static void getPlayerScore(String playerFile) {
    if (playerFile == null || playerFile.isEmpty()) {
        //throwing custom exception
        //throw new IllegalArgumentException("Player file cannot be null");
        throw new MyException("Player file cannot be null");
    }
    System.out.println(playerFile);
}
```