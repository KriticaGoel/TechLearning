### Agenda
1. Sharding
   * Definition
   * Objective
   * Sharding Key
2. Types of Sharding
   * Range-Based Sharding
   * Hash-Based Sharding
   *  Directory-Based Sharding
   *  Composite Sharding
   *  Geo-Based Sharding
3. Sharding Algorithms
    * Modulo
    * Range-Based
    * Consistent Hashing
    * Optimized Consistent Hashing
    * Dynamic Sharding Algorithms
    * Machine Learning-Based Sharding
4. Sharding vs Replication


## Sharding
A database partitioning technique that divides a large database(unable to fit in one machine) into smaller, more manageable pieces called shards, each hosted on a separate database server to improve performance and scalability.

Sharding is simply "Horizontal Partitioning across server".

Which data in which machine is decided by developer or system designer based on the sharding key.

**Objective of sharding**:
1. Improve performance by distributing the load across multiple servers.
2. Enhance scalability by allowing the system to grow by adding more servers.
3. Increase availability by isolating failures to individual shards.
4. Reduce latency by placing shards closer to users geographically.
5. Optimize resource utilization by balancing the data and workload across servers.
6. Facilitate easier maintenance and management of large datasets.
7. Enable handling of large volumes of data that exceed the capacity of a single server.
8. Support high-throughput applications by distributing read and write operations across multiple shards.
9. Efficient Query Execution.

#### Sharding Key: 
Attribute or set of attributes used to determine how data is distributed across shards.(in which shrad a particular row will go)

### Types of Sharding:
1. **Range-Based Sharding** - Data is divided based on ranges of a specific attribute (e.g., user ID ranges).

Possible Example: Users with IDs 1-1000 go to Shard 1, 1001-2000 go to Shard 2, and so on.

Pros:
* Simple to implement and understand.
* Efficient for range queries.
* Easy to scale by adding new shards for new ranges.

Cons:
* Can lead to uneven data distribution if ranges are not well-defined.
* Hotspots may occur if certain ranges receive significantly more traffic.
* Rebalancing shards can be complex if data distribution changes over time.

When to use:
* When data can be logically divided into ranges.
* When queries often target specific ranges of data.
* When there is a need for ordered data retrieval.

Real applications:
* Time-series data (e.g., logs, sensor data)
* E-commerce platforms (e.g., product IDs, order dates)
* Social media applications (e.g., user IDs, post timestamps)

2. Hash-Based Sharding - A hash function is applied to a specific attribute to determine the shard placement.
   Possible Example: A hash function is applied to the user ID, and the result determines which shard the data goes to.
   Pros:
* Provides a more uniform data distribution.
* Reduces the likelihood of hotspots.
* Easier to scale by adding new shards and rehashing data.
* Handles high write loads effectively.
* Good for workloads with random access patterns.
* Minimizes data skew.
* Facilitates load balancing across shards.
* Simplifies shard management.
* Supports high concurrency.
* Enables efficient use of storage resources.
* Improves fault tolerance by distributing data evenly.
* Enhances performance for read and write operations.

Cons:
* More complex to implement due to the need for a hash function.
* Can make range queries less efficient.
* Rehashing may be required when adding or removing shards.

When to use:
* When uniform data distribution is critical.
* When the workload involves random access patterns.
* When scalability and load balancing are priorities.

Real applications:
* Large-scale web applications (e.g., user profiles, session data)
* Content delivery networks (e.g., caching content based on URL hashes)
* Distributed databases (e.g., NoSQL databases like Cassandra, MongoDB)

3. Directory-Based Sharding - A lookup table is maintained to map data to specific shards.

Possible Example: A directory maps user IDs to specific shards based on predefined rules.

Pros:
* Provides flexibility in data distribution.
* Allows for complex sharding strategies.
* Easy to change shard assignments without rehashing data.
* Facilitates dynamic shard management.
* Enables fine-grained control over data placement.
* Supports heterogeneous shard configurations.
* Simplifies data migration between shards.
* Enhances data locality for specific access patterns.

Cons:
* Introduces additional overhead for maintaining the directory.
* Can become a bottleneck if the directory is not efficiently managed.
* Increases complexity in shard management.
* Requires careful design to avoid single points of failure.

When to use:
* When data distribution needs to be highly customizable.
* When shard assignments may change frequently.
* When complex access patterns require specific data placements.

Real applications:
* Multi-tenant applications (e.g., SaaS platforms with varying tenant requirements)
* Applications with dynamic data distribution needs (e.g., gaming platforms)
* Content management systems (e.g., CMS with diverse content types)
4. Composite Sharding - Combines multiple sharding strategies to optimize data distribution.

Possible Example: Using range-based sharding for user IDs and hash-based sharding for session data

Pros:
* Leverages the strengths of multiple sharding techniques.
* Provides flexibility in handling diverse data types.
* Optimizes performance for different access patterns.
* Enhances scalability by combining strategies.
* Improves fault tolerance by diversifying data distribution methods.
* Enables tailored data placement for specific workloads.
* Facilitates efficient resource utilization across shards.
* Supports complex application requirements.
* Enhances overall system performance by optimizing data access.

Cons:
* Increases complexity in implementation and management.
* Requires careful planning to avoid conflicts between sharding strategies.
* May introduce additional overhead in shard management.
* Requires sophisticated monitoring to ensure optimal performance.

When to use:
* When dealing with diverse data types and access patterns.
* When single sharding strategies do not meet performance requirements.
* When scalability and flexibility are critical.

Real applications:
* E-commerce platforms (e.g., combining product and user data sharding)
* Social media applications (e.g., combining user profiles and content data sharding)
* Educational platforms (e.g., combining student and course data sharding)

5. Geo-Based Sharding - Data is partitioned based on geographical location to reduce latency for users in different regions.

Possible Example: Users from North America are directed to Shard 1, while users from Europe are directed to Shard 2.

Pros:
* Reduces latency by placing data closer to users.
* Improves performance for geographically distributed user bases.
* Enhances user experience by minimizing response times.
* Facilitates compliance with data residency regulations.
* Supports localized data management.
* Enables efficient handling of region-specific workloads.
* Improves fault tolerance by isolating regional failures.

Cons:
* Can lead to uneven data distribution if user bases are not evenly spread.
* Requires careful management of data synchronization across regions.
* May introduce complexity in shard management due to geographical considerations.
* Requires robust infrastructure to support global distribution.

When to use:
* When serving a global user base with significant geographical distribution.
* When latency reduction is a priority for user experience.
* When compliance with regional data regulations is necessary.

Real applications:
* Global e-commerce platforms (e.g., Amazon, eBay)
* Social media networks (e.g., Facebook, Twitter)
* Content delivery networks (e.g., Akamai, Cloudflare)
* Online gaming platforms (e.g., Fortnite, PUBG)
* Video streaming services (e.g., Netflix, YouTube)
* Cloud service providers (e.g., AWS, Azure, Google Cloud)
* Financial services (e.g., international banking platforms)
* Travel and booking platforms (e.g., Airbnb, Booking.com)
* News and media websites (e.g., BBC, CNN)
* Educational platforms with global reach (e.g., Coursera, edX)
* Healthcare platforms serving multiple regions (e.g., telemedicine services)
* Collaboration tools (e.g., Slack, Microsoft Teams)
* Ride-sharing services (e.g., Uber, Lyft)
* Food delivery services (e.g., Uber Eats, DoorDash)
* Online marketplaces (e.g., Etsy, Alibaba)
* Real-time communication platforms (e.g., Zoom, Skype)
* Cloud-based productivity suites (e.g., Google Workspace, Microsoft 365)
* Online forums and communities (e.g., Reddit, Stack Overflow)
* E-learning platforms with international users (e.g., Duolingo, Khan Academy)
* Virtual event platforms (e.g., Hopin, Eventbrite)
* Remote work platforms (e.g., GitHub, GitLab)
* Global logistics and supply chain platforms (e.g., FedEx, DHL)

Summary/ Table having different type of Sharding and when to use and when to avoid with real applications:

| Sharding Type        | When to Use                                         | When to Avoid                                      | Real Applications                                  |
|----------------------|-----------------------------------------------------|----------------------------------------------------|---------------------------------------------------|
| Range-Based Sharding | Logical data ranges, range queries                  | Uneven data distribution, hotspots                    | Time-series data, e-commerce, social media        |
| Hash-Based Sharding | Uniform distribution, random access patterns       | Complex implementation, inefficient range queries   | Web applications, CDNs, distributed databases |
| Directory-Based Sharding | Customizable distribution, dynamic shard assignments | Directory overhead, single points of failure          | Multi-tenant apps, dynamic data distribution, CMS  |
| Composite Sharding | Diverse data types, complex access patterns         | Increased complexity, management overhead           | E-commerce, social media, educational platforms |
| Geo-Based Sharding  | Global user base, latency reduction                     | Uneven distribution, data synchronization complexity | Global e-commerce, social media, CDNs            |


#### Sharding Algorithms: Tell in which Shard the data will go

1.Modulo: Example: Sharding key is user_id and we have 4 shard (machine)

getShared(user_id) =user_id % number_of_shards

Pros: Simple
Uniform Distribution if sharding key is uniformly distributed

Cons: scalability issue - when we add or remove the shard we need to do lot of data transfer between Shards.

2.Range-Based: Define ranges for each shard like 0-250 to Shard 1, 251-500 to Shard 2 so on....

Pros: Simple to implement and understand.
Efficient for range queries.
Easy to scale by adding new shards for new ranges.

Cons: Can lead to uneven data distribution if ranges are not well-defined.
Hotspots may occur if certain ranges receive significantly more traffic.
Rebalancing shards can be complex if data distribution changes over time.

3. Consistent Hashing: Use a hash function to map both data and shards to a circular space. Data is assigned to the nearest shard in the clockwise direction.

Pros: Scalability - Adding or removing a shard only affects a small portion of the data.
Reduces data movement during scaling operations.
Provides a more uniform data distribution.

Cons: Reduce load of only one Shared.
More complex to implement.
May require virtual nodes to improve distribution.
Can make range queries less efficient.

When to use: When scalability is a priority.
When dealing with dynamic shard membership.
When uniform data distribution is critical.

4. Optimized Consistent Hashing: An enhanced version of consistent hashing that incorporates virtual nodes and load balancing techniques to further optimize data distribution and minimize hotspots.
* This is used by MangoDB internally
* Use Multiple hash function to find number of shard for a particular key. and load he data on all those Shards.

5. Dynamic Sharding Algorithms: Algorithms that adapt to changing data patterns and workloads in real-time, optimizing shard assignments based on current system conditions.
6. Machine Learning-Based Sharding: Utilizing machine learning techniques to predict data access patterns and optimize

#### Sharding vs Replication


#### Summary of Sharding Algorithms:

| Sharding Algorithm        | Speed          | Uniform Distribution | Scalability     | Complexity      |
|---------------------------|----------------|----------------------|-----------------|-----------------|
| Modulo        | Fast          | Uniform Distribution | NA     | Simple     |
| Range Based          | Fast          | NA | Add and remove easy     | Simple      |
| Consistent Hashing       | Moderate       | Good                 | High            | Moderate        |

